

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>How It Works &mdash; NVTabular 2020 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples/index.html" />
    <link rel="prev" title="NVTabular | API documentation" href="Introduction.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> NVTabular
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">How it Works</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#operations">Operations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-higher-level-of-abstraction">A higher level of abstraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#framework-interoperability">Framework Interoperability</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-gpu-support">Multi-GPU Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-node-support">Multi-Node Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multihot-encoding-and-pre-existing-embeddings">MultiHot Encoding and Pre-existing Embeddings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cpu-support">CPU Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="#getting-your-data-ready-for-nvtabular">Getting your data ready for NVTabular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#troubleshooting">Troubleshooting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#checking-the-schema-of-parquet-files">Checking the schema of parquet files</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/NVIDIA/NVTabular">Github Repo</a></li>
<li class="toctree-l1"><a class="reference internal" href="Resources.html">Resources</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">NVTabular</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>How It Works</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="how-it-works">
<h1>How It Works<a class="headerlink" href="#how-it-works" title="Permalink to this headline">¶</a></h1>
<p><img alt="NVTabular Workflow" src="_images/nvt_workflow.png" /></p>
<p>With the transition to v0.2 the NVTabular engine uses the <a class="reference external" href="http://www.rapids.ai">RAPIDS</a> <a class="reference external" href="https://github.com/rapidsai/dask-cuda">Dask-cuDF library</a> which provides the bulk of the functionality, accelerating dataframe operations on the GPU, and scaling across multiple GPUs.  NVTabular provides functionality commonly found in deep learning recommendation workflows, allowing you to focus on what you want to do with your data, not how you need to do it. We also provide a template for our core compute mechanism, Operations, or ‘ops’ allowing you to build your own custom ops from cuDF and other libraries.</p>
<p>Follow our <a class="reference external" href="https://nvidia.github.io/NVTabular/main/Introduction.html#getting-started">getting started guide</a> to get NVTabular installed on your container or system. Once installed, the next step is to define the preprocessing and feature engineering pipeline by applying the ops you need as defined in the following sections.</p>
<div class="section" id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h2>
<p>Operations are a reflection of the way in which compute happens on the GPU across large datasets. At a high level we’re concerned with two types of compute: the type that touches the entire dataset (or some large chunk of it) and the type that operates on a single row. Operations split the compute such that the first phase, which we call statistics gathering, is the only place where operations that cross the row boundary can take place. An example of this would be in the Normalize op which relies on two statistics, the mean and standard deviation. In order to normalize a row, we must first have calculated these two values, and we use a Dask-cudf graph to compute this part of the op.</p>
<p>The second phase of operations is the transform phase, which uses the statistics created earlier to modify the dataset, transforming the data. Notably we allow for the application of transforms not only during the modification of the dataset, but also during dataloading, with plans to support the same transforms during inference.</p>
<p>With the release of v0.4, we are extending our preprocessing and feature engineering workflows to be directed graphs of operators applied onto user defined groups of columns. Defining this graph is decoupled from the Workflow class, and lets our users easily define complicated graphs of operations on their own custom defined sets of columns. Our Workflow is changed to adopt a similar API to that found with transformers in <a class="reference external" href="https://scikit-learn.org/stable/data_transforms.html">scikit-learn</a>: statistics will be calculated with a ‘fit’ method and applied with a ‘transform’ method. The NVTabular Dataset object is extended to handle both input and output of datasets with the ‘transform’ method of the workflow  taking an input Dataset and returning as output a transformed Dataset.</p>
<p>An op can be applied to a ColumnGroup from an overloaded &gt;&gt; operator, which returns a new ColumnGroup that more Operators can be applied to (see example below). A ColumnGroup is a list of string column names, and the operators work on every column in the ColumnGroup.</p>
<p>In this example, CONT_COLUMNS represents a group of columns for continuous features. We can apply multiple ops basically by chaining the operators to CONT_COLUMNS to obtain transformed continuous features.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">CONT_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;col1 name&#39;</span><span class="p">,</span> <span class="s1">&#39;col2 name&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">cont_features</span> <span class="o">=</span> <span class="n">CONT_COLUMNS</span> <span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">op1</span><span class="o">&gt;</span> <span class="o">&gt;&gt;</span> <span class="o">&lt;</span><span class="n">op2</span><span class="o">&gt;</span> <span class="o">&gt;&gt;</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="a-higher-level-of-abstraction">
<h2>A higher level of abstraction<a class="headerlink" href="#a-higher-level-of-abstraction" title="Permalink to this headline">¶</a></h2>
<p>NVTabular code is targeted at the operator level, not the dataframe level, providing a method for specifying the operation you want to perform, and the columns or type of data that you want to perform it on. We have two types of Operators. The base Operator class is responsible for transforming columns through a ‘transform’ method. This method takes a cudf dataframe object and list of columns to process, and return a transformed cudf dataframe object. The Operator class also declares what columns the operator produces via the ‘output_columns_names’ method, and declare what additional column groups it needs through a ‘dependencies’ method.</p>
<p>There is also a subclass StatOperator that has a ‘fit’ method to calculate statistics on a dask dataframe, a ‘finalize’ method to combine different statistics from various dask workers, as well as save/load methods to handle serialization.</p>
<p>We created a flexible method of defining the operators in our Workflow, which we treat as a directed acyclic graph of operators on set of columns. Operators take in a set of columns of the same type and perform the operation across each column, transforming the output during the final operation into a long tensor in the case of categorical variables or a float tensor in the case of continuous variables. Operators may also be chained to allow for more complex feature engineering or preprocessing. Chaining Operators to the ColumnGroup defines the graph necessary to produce the output dataset. All operators here work by replacing columns in a chain, i.e., transform the columns while retaining the same column names.</p>
<p>Here is a holistic example of the processing a workflow:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nvtabular</span> <span class="k">as</span> <span class="nn">nvt</span>
<span class="kn">from</span> <span class="nn">nvtabular</span> <span class="kn">import</span> <span class="n">ops</span>

<span class="c1"># define set of columns</span>
<span class="n">cat_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;user_id&quot;</span><span class="p">,</span> <span class="s2">&quot;item_id&quot;</span><span class="p">,</span> <span class="s2">&quot;city&quot;</span><span class="p">],</span>
<span class="n">cont_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;age&quot;</span><span class="p">,</span> <span class="s2">&quot;time_of_day&quot;</span><span class="p">,</span> <span class="s2">&quot;item_num_views&quot;</span><span class="p">],</span>
<span class="n">label_column</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>

<span class="c1"># by default, the op will be applied to all</span>
<span class="c1"># columns of the each ColumnGroup</span>
<span class="n">cat_features</span> <span class="o">=</span> <span class="n">cat_columns</span> <span class="o">&gt;&gt;</span> <span class="n">ops</span><span class="o">.</span><span class="n">Categorify</span><span class="p">()</span>
<span class="n">cont_features</span> <span class="o">=</span> <span class="n">cont_columns</span> <span class="o">&gt;&gt;</span> <span class="n">ops</span><span class="o">.</span><span class="n">FillMissing</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="n">ops</span><span class="o">.</span><span class="n">Normalize</span><span class="p">()</span>
<span class="n">label_feature</span> <span class="o">=</span> <span class="n">label_column</span> <span class="o">&gt;&gt;</span> <span class="n">ops</span><span class="o">.</span><span class="n">LogOp</span><span class="p">()</span>

<span class="c1"># A NVTabular workflow orchastrates the pipelines</span>
<span class="c1"># We create the NVTabular workflow with the output ColumnGroups</span>
<span class="n">proc</span> <span class="o">=</span> <span class="n">nvt</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">cat_features</span> <span class="o">+</span> <span class="n">cont_features</span> <span class="o">+</span> <span class="n">label_feature</span><span class="p">)</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">nvt</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="s2">&quot;/path/to/data.parquet&quot;</span><span class="p">)</span>
<span class="c1"># Calculate statistics on the training set</span>
<span class="n">proc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>

<span class="c1"># record stats, transform the dataset, and export</span>
<span class="c1"># the transformed data to a parquet file</span>
<span class="n">proc</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">output_path</span><span class="o">=</span><span class="s2">&quot;/path/to/export/dir&quot;</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="n">nvt</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">Shuffle</span><span class="o">.</span><span class="n">PER_WORKER</span><span class="p">)</span>
</pre></div>
</div>
<p>We can easily convert this workflow definition to a graph, and visualize the full workflow by concatenating the output ColumnGroups.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">cat_features</span><span class="o">+</span><span class="n">cont_features</span><span class="o">+</span><span class="n">label_feature</span><span class="p">)</span><span class="o">.</span><span class="n">graph</span>
</pre></div>
</div>
<p><img alt="NVTabular Workflow Graph" src="_images/nvt_workflow_graph.png" /></p>
<p>Note that, we also developed a new operator, ‘Rename’, which can flexibly handle changing the names of columns. This operator provides several different options for renaming columns, including applying a user defined function to get new column names as well as just appending a suffix to each column. You can see the <a class="reference external" href="https://github.com/NVIDIA/NVTabular/tree/new_api/examples/wnd_outbrain">Outbrain</a> example for usage of the Rename op.</p>
</div>
<div class="section" id="framework-interoperability">
<h2>Framework Interoperability<a class="headerlink" href="#framework-interoperability" title="Permalink to this headline">¶</a></h2>
<p>In addition to providing mechanisms for transforming the data to prepare it for deep learning models we also provide framework-specific dataloaders to help optimize getting that data to the GPU.  Under a traditional dataloading scheme, data is read in item by item and collated into a batch. PyTorch allows for multiple processes to create many batches at the same time, however this still leads to many individual rows of tabular data accessed independently which impacts I/O, especially when this data is on the disk and not in CPU memory.  TensorFlow loads and shuffles TFRecords by adopting a windowed buffering scheme that loads data sequentially to a buffer, from which it randomly samples batches and replenishes with the next sequential elements from disk. Larger buffer sizes ensure more randomness, but can quickly bottleneck performance as TensorFlow tries to keep the buffer saturated. Smaller buffer sizes mean that datasets which aren’t uniformly distributed on disk lead to biased sampling and potentially degraded convergence.</p>
<p>In NVTabular we provide an option to shuffle during dataset creation, creating a uniformly shuffled dataset allowing the dataloader to read in contiguous chunks of data that are already randomized across the entire dataset. NVTabular provides the option to control the number of chunks that are combined into a batch, allowing the end user flexibility when trading off between performance and true randomization.  This mechanism is critical when dealing with datasets that exceed CPU memory and per epoch shuffling is desired during training.  Full shuffle of such a dataset can exceed training time for the epoch by several orders of magnitude.</p>
<p>Stay tuned for benchmarks on our dataloader performance as compared to those native frameworks.</p>
</div>
<div class="section" id="multi-gpu-support">
<h2>Multi-GPU Support<a class="headerlink" href="#multi-gpu-support" title="Permalink to this headline">¶</a></h2>
<p>NVTabular supports multi-GPU scaling with <a class="reference external" href="https://github.com/rapidsai/dask-cuda">Dask-CUDA</a> and <a class="reference external" href="https://distributed.dask.org/en/latest/">dask.distributed</a>.  To enable distributed parallelism, the NVTabular <code class="docutils literal notranslate"><span class="pre">Workflow</span></code> must be initialized with a <code class="docutils literal notranslate"><span class="pre">dask.distributed.Client</span></code> object:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">nvtabular</span> <span class="k">as</span> <span class="nn">nvt</span>
<span class="kn">from</span> <span class="nn">dask.distributed</span> <span class="kn">import</span> <span class="n">Client</span>

<span class="c1"># Deploy a new cluster</span>
<span class="c1"># (or specify the port of an existing scheduler)</span>
<span class="n">cluster</span> <span class="o">=</span> <span class="s2">&quot;tcp://MachineA:8786&quot;</span>

<span class="n">client</span> <span class="o">=</span> <span class="n">Client</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">proc</span> <span class="o">=</span> <span class="n">nvt</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">cat_features</span> <span class="o">+</span> <span class="n">cont_features</span> <span class="o">+</span> <span class="n">label_feature</span><span class="p">,</span> <span class="n">client</span><span class="o">=</span><span class="n">client</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Dask-cuDF does the scheduling to help optimize the task graph providing an optimal solution to whatever configuration of GPUs you have, from a single GPU to a cluster of many. There are currenly many ways to deploy a “cluster” for Dask.  <a class="reference external" href="https://blog.dask.org/2020/07/23/current-state-of-distributed-dask-clusters">This article</a> gives a nice summary of all practical options.  For a single machine with multiple GPUs, the <code class="docutils literal notranslate"><span class="pre">dask_cuda.LocalCUDACluster</span></code> API is typically the most convenient option.</p>
<p>Since NVTabular already uses <a class="reference external" href="https://docs.rapids.ai/api/cudf/stable/dask-cudf.html">Dask-CuDF</a> for internal data processing, there are no other requirements for multi-GPU scaling.  With that said, the parallel performance can depend strongly on (1) the size of <code class="docutils literal notranslate"><span class="pre">Dataset</span></code> partitions, (2) the shuffling procedure used for data output, and (3) the specific arguments used for both global-statistics and transformation operations. See the <a class="reference external" href="https://github.com/NVIDIA/NVTabular/blob/main/examples/multi-gpu_dask.ipynb">Multi-GPU</a> section of this documentation for a simple step-by-step example.</p>
<p>Users are also encouraged to experiment with the <a class="reference external" href="https://github.com/NVIDIA/NVTabular/blob/main/examples/dask-nvtabular-criteo-benchmark.py">multi-GPU Criteo/DLRM benchmark example</a>. For detailed notes on the parameter space for the benchmark, see the <a class="reference external" href="https://github.com/NVIDIA/NVTabular/blob/main/examples/MultiGPUBench">Multi-GPU Criteo Benchmark</a> section of this documentation.</p>
</div>
<div class="section" id="multi-node-support">
<h2>Multi-Node Support<a class="headerlink" href="#multi-node-support" title="Permalink to this headline">¶</a></h2>
<p>NVTabular supports multi node scaling with <a class="reference external" href="https://github.com/rapidsai/dask-cuda">Dask-CUDA</a> and <a class="reference external" href="https://distributed.dask.org/en/latest/">dask.distributed</a>.  To enable distributed parallelism, we need to start a cluster and then connect to it to run the application.</p>
<ol class="simple">
<li><p>Start the scheduler <code class="docutils literal notranslate"><span class="pre">dask-scheduler</span></code></p></li>
<li><p>Start the workers <code class="docutils literal notranslate"><span class="pre">dask-cuda-worker</span> <span class="pre">schedulerIP:schedulerPort</span></code></p></li>
<li><p>Run the NVTabular application where the NVTabular <code class="docutils literal notranslate"><span class="pre">Workflow</span></code> has been initialized as described in the Multi-GPU Support section.</p></li>
</ol>
<p>For a detailed description of all the existing methods to start a cluster, please read <a class="reference external" href="https://blog.dask.org/2020/07/23/current-state-of-distributed-dask-clusters">this article</a>.</p>
</div>
<div class="section" id="multihot-encoding-and-pre-existing-embeddings">
<h2>MultiHot Encoding and Pre-existing Embeddings<a class="headerlink" href="#multihot-encoding-and-pre-existing-embeddings" title="Permalink to this headline">¶</a></h2>
<p>NVTabular now supports processing datasets with multihot categorical columns, and also supports passing along
vector continuous features like pretrained embeddings. This support includes basic preprocessing
and feature engineering ability, as well as full support in the dataloaders for training models
using these features with both TensorFlow and PyTorch.</p>
<p>Multihots let you represent a set of categories as a single feature. For example, in a movie recommendation system each movie might
have a list of genres associated with the movie like comedy, drama, horror or science fiction. Since movies can
belong to more than one genre we can’t use single-hot encoding like we are doing for scalar
columns. Instead we train models with multihot embeddings for these features, with the deep
learning model looking up an embedding for each categorical in the list and then summing all the
categories for each row.</p>
<p>Both multihot categoricals and vector continuous features are represented using list columns in
our datasets. cuDF has recently added support for list columns, and we’re leveraging that support in NVTabular
0.3 to power this feature.</p>
<p>We’ve added support to our Categorify and HashBucket operators to map list columns down to small
contiguous integers suitable for use in an embedding lookup table. That is if you pass a dataset
containing two rows like <code class="docutils literal notranslate"><span class="pre">[['comedy',</span> <span class="pre">'horror'],</span> <span class="pre">['comedy',</span> <span class="pre">'sciencefiction']]</span></code> we can transform
the strings for each into categorical ids like <code class="docutils literal notranslate"><span class="pre">[[0,</span> <span class="pre">1],</span> <span class="pre">[0,</span> <span class="pre">2]]</span></code> that can be used in our embeddings
layers using these two operators.</p>
<p>Our PyTorch and TensorFlow dataloaders have been extended to handle both categorical and
continuous list columns.  In TensorFlow, the KerasSequenceLoader class will transform each list
column into two tensors representing the values and offsets into those values for each batch.
These tensors can be converted into RaggedTensors for multihot columns, and for vector continuous
columns the offsets tensor can be safely ignored. We’ve provided a
<code class="docutils literal notranslate"><span class="pre">nvtabular.framework_utils.tensorflow.layers.DenseFeatures</span></code> Keras layer that will
automatically handle these conversions for both continuous and categorical columns. For PyTorch,
we’ve added support for multihot columns to our
<code class="docutils literal notranslate"><span class="pre">nvtabular.framework_utils.torch.models.Model</span></code> class, which internally is using the PyTorch
<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.EmbeddingBag.html">EmbeddingBag</a> layer to
handle the multihot columns.</p>
</div>
<div class="section" id="cpu-support">
<h2>CPU Support<a class="headerlink" href="#cpu-support" title="Permalink to this headline">¶</a></h2>
<p>Operators will also be developed using pandas to provide support for users who don’t have access to GPU resources and who wish to use the higher level API that NVTabular provides.  We will try to provide support and feature parity for CPU but GPU acceleration is the focus of this library. Check the API documentation for coverage.</p>
</div>
<div class="section" id="getting-your-data-ready-for-nvtabular">
<h2>Getting your data ready for NVTabular<a class="headerlink" href="#getting-your-data-ready-for-nvtabular" title="Permalink to this headline">¶</a></h2>
<p>NVTabular is designed with a specific type of dataset in mind. Ideally, the dataset will have the following characteristics:</p>
<ol class="simple">
<li><p>Comprises 1+ parquet files</p></li>
<li><p>All parquet files must have the same schema (including column types and nullable (“not null”) option)</p></li>
<li><p>Each parquet file consists of row-groups around 128MB in size</p></li>
<li><p>Each parquet file is large enough to map onto an entire dask_cudf.DataFrame partition. This typically means &gt;=1GB.</p></li>
<li><p>All parquet files should be located within a “root” directory, and that directory should contain a global “_metadata” file.
<em>Note</em>: This “_metadata” file allows the dask_cudf client to produce a DataFrame collection much faster, because all metadata can be accessed from a single file. When this file is not present, the client needs to aggregate footer metadata from all files in the dataset.</p></li>
</ol>
<p>CSV files are support but not recommended, because they are not efficiently stored and loaded into memory compared to parquet files (columnar format).</p>
<div class="section" id="troubleshooting">
<h3>Troubleshooting<a class="headerlink" href="#troubleshooting" title="Permalink to this headline">¶</a></h3>
<div class="section" id="checking-the-schema-of-parquet-files">
<h4>Checking the schema of parquet files<a class="headerlink" href="#checking-the-schema-of-parquet-files" title="Permalink to this headline">¶</a></h4>
<p>NVTabular expects that all input parquet files have the same schema (including column types and nullable (not null) option).	
If you get the error <code class="docutils literal notranslate"><span class="pre">RuntimeError:</span> <span class="pre">Schemas</span> <span class="pre">are</span> <span class="pre">inconsistent,</span> <span class="pre">try</span> <span class="pre">using</span> <span class="pre">to_parquet(...,</span> <span class="pre">schema=&quot;infer&quot;),</span> <span class="pre">or</span> <span class="pre">pass</span> <span class="pre">an</span> <span class="pre">explicit</span> <span class="pre">pyarrow</span> <span class="pre">schema.</span> <span class="pre">Such</span> <span class="pre">as</span> <span class="pre">to_parquet(...,</span> <span class="pre">schema={&quot;column1&quot;:</span> <span class="pre">pa.string()})</span></code> when you load the dataset as below, some parquet file might have a different schema:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>ds = nvt.Dataset(PATH, engine=&quot;parquet&quot;, part_size=&quot;1000MB&quot;)	
ds.to_ddf().head()	
```	
The easiest way to fix this is to load your dataset with dask_cudf and save it again to parquet format ( `dask_cudf.read_parquet(&quot;INPUT_FOLDER&quot;).to_parquet(&quot;OUTPUT_FOLDER&quot;)`), so that files are standardized and the `_metadata` file is generated.	
If you want to identify which parquet files and which columns have a different schema, you may run one of these scripts, using either [PyArrow](https://github.com/dask/dask/issues/6504#issuecomment-675465645) or [cudf=0.17](https://github.com/rapidsai/cudf/pull/6796#issue-522934284), which checks the consistency and generates only the ```_metadata``` file, rather than converting all parquet files. If the schema is not consistent across all files, the script will raise an exception describing inconsistent files with schema for troubleshooting. More info in this issue [here](https://github.com/NVIDIA/NVTabular/issues/429).

##### Checking and Setting the row group size of parquet files
The `row_group_size` is the number of rows that are stored in each row group (internal structure within the parquet file).

You can check the current row group size of your parquet files loading only the first row group, using cuDF, as follows:

```python
def _memory_usage(df):
    &quot;&quot;&quot;this function is a workaround of a problem with getting memory usage of lists
    in cudf0.16.  This can be deleted and just use `df.memory_usage(deep= True, index=True).sum()`
    once we are using cudf 0.17 (fixed in https://github.com/rapidsai/cudf/pull/6549)&quot;&quot;&quot;
    size = 0
    for col in df._data.columns:
        if cudf.utils.dtypes.is_list_dtype(col.dtype):
            for child in col.base_children:
                size += child.__sizeof__()
        else:
            size += col._memory_usage(deep=True)
    size += df.index.memory_usage(deep=True)
    return size

import cudf
first_row_group_df = cudf.read_parquet(&#39;/path/to/a/parquet/file&#39;, row_groups=0, row_group=0)
num_rows = len(first_row_group_df)
memory_size = _memory_usage(first_row_group_df)
</pre></div>
</div>
<p>You can set the row group size (number of rows) of your parquet files by using most Data Frame frameworks, like the following examples with Pandas and cuDF:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#Pandas</span>
<span class="n">pandas_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s2">&quot;/file/path&quot;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pyarrow&quot;</span><span class="p">,</span> <span class="n">row_group_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1">#cuDF</span>
<span class="n">cudf_df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="s2">&quot;/file/path&quot;</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;pyarrow&quot;</span><span class="p">,</span> <span class="n">row_group_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>The row group <strong>memory</strong> size of the parquet files should be lower than the <strong>part_size</strong> you set for the NVTabular dataset (like in <code class="docutils literal notranslate"><span class="pre">nvt.Dataset(TRAIN_DIR,</span> <span class="pre">engine=&quot;parquet&quot;,</span> <span class="pre">part_size=&quot;1000MB&quot;</span></code>).
To know how much memory a row group will hold, you can slice your dataframe to a specific number of rows and call the above method ( <code class="docutils literal notranslate"><span class="pre">_memory_usage(df)</span></code> ) to get the memory usage in bytes. Then, you can set the row_group_size (number of rows) accordingly when you save the parquet file. A row group memory size of around 128MB is recommended in general.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="examples/index.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Introduction.html" class="btn btn-neutral float-left" title="NVTabular | API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, NVIDIA

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: main
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../v0.1.0/HowItWorks.html">v0.1.0</a></dd>
      <dd><a href="../v0.1.1/HowItWorks.html">v0.1.1</a></dd>
      <dd><a href="../v0.2.0/HowItWorks.html">v0.2.0</a></dd>
      <dd><a href="../v0.3.0/HowItWorks.html">v0.3.0</a></dd>
    </dl>
    <dl>
      <dt>Branches</dt>
      <dd><a href="HowItWorks.html">main</a></dd>
    </dl>
  </div>
</div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>